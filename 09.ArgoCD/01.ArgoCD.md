# ArgoCD 

- 배치 프로세싱 ArgoCD
- ArgoCD 는 오픈소스 컨테이너 중심의 워크플로우 엔진이다. 
- Argo 는 Kubernetes CRD(Custom Resource Definition) 으로 구현된것이다. 
  - 워크플로우 정의, 워크 플로에에서 각 스텝은 컨테이너이다. 
  - 복수 스텝 워크플로우 모델을 지정할 수 있으며, 태스크간의 의존성을 캡쳐할 수 있다. (DAG)
  - 쉽게 실행하고, 컴퓨팅 인텐시브 작업을 수행할 수 있다. 이는 머신 러닝에 이용된다. 

## 소개 

- 배치 프로세싱은 작업의 단위를 반복적이고 사람없이 자동으로 처리되는 것이다. 
- 잡들은 일반적으로 함께 묶여 있다. 그리고 배치로 처리된다. 
- Kubernetes 는 수행되는 작업들을 기본 제공한다. 
- Job은 여러개의 Pod로 복수개로 실행된다. 
- 각 Pod는 작업 하나에 복수개의 컨테이너를 포함할 수 있다. 
- Argo 는 다음 여러가지 기능들을 도입하여 일괄처리를 수행한다. 
  - 워크플로우의 선언을 기준으로 단계를 수행한다. 
  - 아티팩트 지원
  - 스텝 레빌 입력,출력 지원
  - 반복
  - 조건
  - 가시화 (Argo dashboard 이용)

## Kubernetes JOb

- job 생성은 하나 혹은 여러개의 pod를 생성한다. 
- 성공적으로 종료를 위해서 특정 개수를 보장해야한다. 
- pods를 성공적으로 완료하기 위해서 job은 성공, 완료를 트래킹한다. 
- 성공적으로 완료된 작업의 수를 지정하면, 그것을 기준으로 완료로 친다. 
- 잡의 삭제는 생성된 pod를 완료한다. 

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: whalesay
spec:
  template:
    spec:
      containers:
      - name: whalesay
        image: docker/whalesay
        command: ["cowsay",  "This is a Kubernetes Job!"]
      restartPolicy: Never
  backoffLimit: 4
```

다음 명령어로 실행하자. 

```shell
kubectl apply -f job-whalesay.yaml

```

잡이 성공적으로 완료할 수 있도록 대기한다. 

```shell
kubectl get job/whalesay

NAME       DESIRED   SUCCESSFUL   AGE
whalesay   1         1            2m
```

출력정보 확인

```shell
kubectl logs -l job-name=whalesay

 ___________________________ 
< This is a Kubernetes Job! >
 --------------------------- 
    \
     \
      \     
                    ##        .            
              ## ## ##       ==            
           ## ## ## ##      ===            
       /""""""""""""""""___/ ===        
  ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ /  ===- ~~~   
       \______ o          __/            
        \    \        __/             
          \____\______/   

```

## Argo CLI 설치하기. 

```shell
sudo curl -sSL -o /usr/local/bin/argo https://github.com/argoproj/argo/releases/download/v2.2.1/argo-linux-amd64
sudo chmod +x /usr/local/bin/argo

```

## Argo Deploy 수행하기. 

```shell
kubectl create ns argo
kubectl apply -n argo -f https://raw.githubusercontent.com/argoproj/argo/v2.2.1/manifests/install.yaml

```

```shell
namespace/argo created
customresourcedefinition.apiextensions.k8s.io/workflows.argoproj.io created
serviceaccount/argo created
serviceaccount/argo-ui created
clusterrole.rbac.authorization.k8s.io/argo-aggregate-to-admin created
clusterrole.rbac.authorization.k8s.io/argo-aggregate-to-edit created
clusterrole.rbac.authorization.k8s.io/argo-aggregate-to-view created
clusterrole.rbac.authorization.k8s.io/argo-cluster-role created
clusterrole.rbac.authorization.k8s.io/argo-ui-cluster-role created
clusterrolebinding.rbac.authorization.k8s.io/argo-binding created
clusterrolebinding.rbac.authorization.k8s.io/argo-ui-binding created
configmap/workflow-controller-configmap created
service/argo-ui created
deployment.apps/argo-ui created
deployment.apps/workflow-controller created
```

Argo 의 향상된 기능을 이용하기 위해서는 RoleBinding 을 생성하고, admin 권한을 'default' 서비스 어카운트로 할당해 주어야한다. 

경고: 이는 데모 프로세스이다. 다른 환경에서, Workflow RBAC 를 이용해서 적합한 퍼미션을 주어야한다. 

```go
kubectl create rolebinding default-admin --clusterrole=admin --serviceaccount=default:default

```

## Artifact Repository 설정하기. 

Argo 는 artifact 리포지토리를 workflow 에 잡들 사이에 전달된다. 

Amazon S3 들은 아티팩트 리포지토리로 사용된다.

S3버킷을 AWX CLI를 이용하여 생성한다. 

```go
ACCOUNT_ID=$(aws sts get-caller-identity --output text --query Account)
aws s3 mb s3://batch-artifact-repository-${ACCOUNT_ID}/

```

- 계정 정보를 조회하여 할당한다. 
- aws s3를 생성한다. 

다음으로 workflow-controller ConfigMap 을 수정하여 S3 Bucket을 사용하도록 한다. 

```go
kubectl edit -n argo configmap/workflow-controller-configmap

```

그리고 다음 라인을 ConfigMap 마지막에 추가한다. 

```go
data:
  config: |
    artifactRepository:
      s3:
        bucket: batch-artifact-repository-{{ACCOUNT_ID}}
        endpoint: s3.amazonaws.com

```

## IAM Policy 생성하기. 

Argo 가 S3 bucket 에 쓰고, 조회하기 위해서 인라인 정책을 설정할 필요가 있다. 

워커 노드에 EC2 인스턴스 프로파일을 추가한다. 

인스턴스 프로파일 수집, 롤이름, 어카운트 아이디를 CloudFormation 스택으로 수집한다. 

```go
INSTANCE_PROFILE_PREFIX=$(aws cloudformation describe-stacks | jq -r '.Stacks[].StackName' | grep eksctl-eksworkshop-eksctl-nodegroup)

INSTANCE_PROFILE_NAME=$(aws iam list-instance-profiles | jq -r '.InstanceProfiles[].InstanceProfileName' | grep $INSTANCE_PROFILE_PREFIX)

ROLE_NAME=$(aws iam get-instance-profile --instance-profile-name $INSTANCE_PROFILE_NAME | jq -r '.InstanceProfile.Roles[] | .RoleName')

ACCOUNT_ID=$(aws sts get-caller-identity --output text --query Account)

```

워커 노드 롤에 지정하기

```go
mkdir ~/environment/batch_policy
cat <<EoF > ~/environment/batch_policy/k8s-s3-policy.json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:*"
      ],
      "Resource": [
        "arn:aws:s3:::batch-artifact-repository-${ACCOUNT_ID}",
        "arn:aws:s3:::batch-artifact-repository-${ACCOUNT_ID}/*"
      ]
    }
  ]
}
EoF
aws iam put-role-policy --role-name $ROLE_NAME --policy-name S3-Policy-For-Worker --policy-document file://~/environment/batch_policy/k8s-s3-policy.json

```

롤에 연결된 정책을 검증한다. 

```go
aws iam get-role-policy --role-name $ROLE_NAME --policy-name S3-Policy-For-Worker

```

## 단순 배치 워크 플로우 

아래 매니페시트를 저장한다. 'workflow-whalesay.yaml' 으로 이름을 지정한다. 

```go
apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: whalesay-
spec:
  entrypoint: whalesay
  templates:
  - name: whalesay
    container:
      image: docker/whalesay
      command: [cowsay]
      args: ["This is an Argo Workflow!"]

```

argo CLI 를 이용하여 워크플로우를 배포한다. 

노트: kubectl을 사용하여 워크 플로 사양을 직접 수행할 수 있지만, argo CLI는 구문 검사, 더 좋은 출력을 제공하고, 입력이 덜 필요하다. 

```go
argo submit --watch workflow-whalesay.yaml
```

```go
Name:                whalesay-2kfxb
Namespace:           default
ServiceAccount:      default
Status:              Succeeded
Created:             Sat Nov 17 10:32:13 -0500 (3 seconds ago)
Started:             Sat Nov 17 10:32:13 -0500 (3 seconds ago)
Finished:            Sat Nov 17 10:32:16 -0500 (now)
Duration:            3 seconds

STEP               PODNAME         DURATION  MESSAGE
 ✔ whalesay-2kfxb  whalesay-2kfxb  2s        
```

출력으로 부터 워크플로우의 이름의 노트를 수행한다. (whalesay-xxx와 유사하다)

```go
argo logs whalesay-xxxxx

```

```go
 ___________________________ 
< This is an Argo Workflow! >
 --------------------------- 
    \
     \
      \     
                    ##        .            
              ## ## ##       ==            
           ## ## ## ##      ===            
       /""""""""""""""""___/ ===        
  ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ /  ===- ~~~   
       \______ o          __/            
        \    \        __/             
          \____\______/   

```

## 향상된 배치 워크플로우 

더 복잡한 워크플로우를 보고, 아티팩트를 잡들에 복수의 의존성들 사이에 전달한다. 

```go
apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: teardrop-
spec:
  entrypoint: teardrop
  templates:
  - name: create-chain
    container:
      image: alpine:latest
      command: ["sh", "-c"]
      args: ["touch /tmp/message"]
    outputs:
      artifacts:
      - name: chain
        path: /tmp/message
  - name: whalesay
    inputs:
      parameters:
      - name: message
      artifacts:
      - name: chain
        path: /tmp/message
    container:
      image: docker/whalesay
      command: ["sh", "-c"]
      args: ["echo Chain: ; cat /tmp/message* | sort | uniq | tee /tmp/message; cowsay This is Job {{inputs.parameters.message}}! ; echo {{inputs.parameters.message}} >> /tmp/message"]
    outputs:
      artifacts:
      - name: chain
        path: /tmp/message
  - name: whalesay-reduce
    inputs:
      parameters:
      - name: message
      artifacts:
      - name: chain-0
        path: /tmp/message.0
      - name: chain-1
        path: /tmp/message.1
    container:
      image: docker/whalesay
      command: ["sh", "-c"]
      args: ["echo Chain: ; cat /tmp/message* | sort | uniq | tee /tmp/message; cowsay This is Job {{inputs.parameters.message}}! ; echo {{inputs.parameters.message}} >> /tmp/message"]
    outputs:
      artifacts:
      - name: chain
        path: /tmp/message
  - name: teardrop
    dag:
      tasks:
      - name: create-chain
        template: create-chain
      - name: Alpha
        dependencies: [create-chain]
        template: whalesay
        arguments:
          parameters: [{name: message, value: Alpha}]
          artifacts:
            - name: chain
              from: "{{tasks.create-chain.outputs.artifacts.chain}}"
      - name: Bravo
        dependencies: [Alpha]
        template: whalesay
        arguments:
          parameters: [{name: message, value: Bravo}]
          artifacts:
            - name: chain
              from: "{{tasks.Alpha.outputs.artifacts.chain}}"
      - name: Charlie
        dependencies: [Alpha]
        template: whalesay
        arguments:
          parameters: [{name: message, value: Charlie}]
          artifacts:
            - name: chain
              from: "{{tasks.Alpha.outputs.artifacts.chain}}"
      - name: Delta
        dependencies: [Bravo]
        template: whalesay
        arguments:
          parameters: [{name: message, value: Delta}]
          artifacts:
            - name: chain
              from: "{{tasks.Bravo.outputs.artifacts.chain}}"
      - name: Echo
        dependencies: [Bravo, Charlie]
        template: whalesay-reduce
        arguments:
          parameters: [{name: message, value: Echo}]
          artifacts:
            - name: chain-0
              from: "{{tasks.Bravo.outputs.artifacts.chain}}"
            - name: chain-1
              from: "{{tasks.Charlie.outputs.artifacts.chain}}"
      - name: Foxtrot
        dependencies: [Charlie]
        template: whalesay
        arguments:
          parameters: [{name: message, value: Foxtrot}]
          artifacts:
            - name: chain
              from: "{{tasks.create-chain.outputs.artifacts.chain}}"
      - name: Golf
        dependencies: [Delta, Echo]
        template: whalesay-reduce
        arguments:
          parameters: [{name: message, value: Golf}]
          artifacts:
            - name: chain-0
              from: "{{tasks.Delta.outputs.artifacts.chain}}"
            - name: chain-1
              from: "{{tasks.Echo.outputs.artifacts.chain}}"
      - name: Hotel
        dependencies: [Echo, Foxtrot]
        template: whalesay-reduce
        arguments:
          parameters: [{name: message, value: Hotel}]
          artifacts:
            - name: chain-0
              from: "{{tasks.Echo.outputs.artifacts.chain}}"
            - name: chain-1
              from: "{{tasks.Foxtrot.outputs.artifacts.chain}}"

```

- 이 워크플로우는 DAG를 사용하여 작업 종송석을 명시 적으로 정의한다. 
- 워크 플로의 각 작업은 whalesay 템플릿을 호출하고, 고유한 이름으로 매개 변수를 전달한다. 
- 일부 작업은 여러 아티팩트를 받아 하나의 아티팩트로 결합하는 whalesay-reduce 템플릿을 호출한다. 
- 워크플로우에 각 작업은 아티팩트를 가져오고, 이를 체인에 낭려한다. 
- 각 job은 이전 잡의 체인의 목록을 가진다. 

워크플로우 실행하기. 

```go
argo submit --watch teardrop.yaml

```

```go
Name:                teardrop-jfg5w
Namespace:           default
ServiceAccount:      default
Status:              Succeeded
Created:             Sat Nov 17 16:01:42 -0500 (7 minutes ago)
Started:             Sat Nov 17 16:01:42 -0500 (7 minutes ago)
Finished:            Sat Nov 17 16:03:35 -0500 (5 minutes ago)
Duration:            1 minute 53 seconds

STEP               PODNAME                    DURATION  MESSAGE
 ✔ teardrop-jfg5w                                       
 ├-✔ create-chain  teardrop-jfg5w-3938249022  3s        
 ├-✔ Alpha         teardrop-jfg5w-3385521262  6s        
 ├-✔ Bravo         teardrop-jfg5w-1878939134  35s       
 ├-✔ Charlie       teardrop-jfg5w-3753534620  35s       
 ├-✔ Foxtrot       teardrop-jfg5w-2036090354  5s        
 ├-✔ Delta         teardrop-jfg5w-37094256    34s       
 ├-✔ Echo          teardrop-jfg5w-4165010455  31s       
 ├-✔ Hotel         teardrop-jfg5w-2342859904  4s        
 └-✔ Golf          teardrop-jfg5w-1687601882  30s       

```

## Argo 대시보드 

- 워크플로 목록을 나열하고, 각 워크플로우를 가시화 한다. 
- https://awskrug.github.io/eks-workshop/dashboard/dashboard/ 연결 설정을 추가할 수 있다. 
  
접속 커맨드 

```go
kubectl proxy --port=8080 --address='0.0.0.0' --disable-filter=true &

```

이는 프록시를 시작할 것이고, 포트 8080에 나열한다. 모든 인터페이스에서 수신하고, 비 localhost요청의 필터링을 비활성화 한다. 

주의: XSRF 공격으로 부터 보호하는 보안 기능인 요청 필터링을 비활성화 합니다. 프러덕션 환경에는 권장되지 않지만 개발 환경에는 유용합니다. 

- Argo Dashboard 로 접근한다. 
  - Cloud9 환경에서, Preview/Preview Running Application 클릭
  - the end of the URL을 스크롤 하고 접근하자. 

```go
/api/v1/namespaces/argo/services/argo-ui/proxy/

```

로 접근할 수 있다. 


## 워크플로우 삭제방법

```go
argo delete --all
```

## 아티팩트 리포지토리 버킷 삭제 

```go
ACCOUNT_ID=$(aws sts get-caller-identity --output text --query Account)
aws s3 rb s3://batch-artifact-repository-${ACCOUNT_ID}/ --force
```

## 아티팩트 리포지토리 버킷을 위한 퍼미션 삭제 

```go
INSTANCE_PROFILE_PREFIX=$(aws cloudformation describe-stacks | jq -r '.Stacks[].StackName' | grep eksctl-eksworkshop-eksctl-nodegroup)

INSTANCE_PROFILE_NAME=$(aws iam list-instance-profiles | jq -r '.InstanceProfiles[].InstanceProfileName' | grep $INSTANCE_PROFILE_PREFIX)

ROLE_NAME=$(aws iam get-instance-profile --instance-profile-name $INSTANCE_PROFILE_NAME | jq -r '.InstanceProfile.Roles[] | .RoleName')

ACCOUNT_ID=$(aws sts get-caller-identity --output text --query Account)

aws iam delete-role-policy --role-name $ROLE_NAME --policy-name S3-Policy-For-Worker

```

## Argo 삭제 

```go
kubectl delete -n argo -f https://raw.githubusercontent.com/argoproj/argo/v2.2.1/manifests/install.yaml

kubectl delete ns argo

```

## 쿠버네티스 잡 삭제 

```go
kubectl delete job/whalesay

```

