# CI/CD CodePipeline

- CI: Continuous Integration
- CD: Continuous Delivery
- CI/CD 는 빠른게 개발하는 조직에서는 필수 요소 
- 팀의 생산성이 증대되며, 변경에 대해서 민감하게 움직일 수 있다. 
- 프로그램적으로 변경을 쉽게 릴리즈 하고, 혼란 없이 변경사항을 전달할 수 있게 된다. 
- AWS CodePipeline 를 이용하여 이를 자동화 할 수 있다. 
  
## IAM Role 생성하기. 

- AWS CodePipeline 을 위해서 AWS CodeBuild 를 이용하여 Kubernetes service 샘플을 배포한다. 
- 이를 위해서는 IAM 롤을 지정해 주어야한다. (이는 EKS Cluster와 연동해서 동작한다.)

### Role 생성하기. 

```go
cd ~/environment

// sts를 이용하여 계정 정보를 조회하고, 환경 변수에 세팅한다. 
ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

// AssumeRole 을 위한 환경 변수를 설정한다. 
TRUST="{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::${ACCOUNT_ID}:root\" }, \"Action\": \"sts:AssumeRole\" } ] }"

// iam role을 위해서 환경 변수를 설정한다. 
echo '{ "Version": "2012-10-17", "Statement": [ { "Effect": "Allow", "Action": "eks:Describe*", "Resource": "*" } ] }' > /tmp/iam-role-policy

// iam 롤을 생성한다. 
aws iam create-role --role-name EksWorkshopCodeBuildKubectlRole --assume-role-policy-document "$TRUST" --output text --query 'Role.Arn'

// iam 폴리시 정보를 롤에 할당한다. 
aws iam put-role-policy --role-name EksWorkshopCodeBuildKubectlRole --policy-name eks-describe --policy-document file:///tmp/iam-role-policy                                                                                                                                                                                      
```

## ConfigMap 설정하기. 

- IAM Role이 생성되고 난 후, aws-auth ConfigMap 에 롤에 대한 설정을 추가한다. 
- ConfigMap 에 새로운 롤이 설정되면, 파이프 라인의 CodeBuild 단계에 있는 kubectl 은 IAM 역할을 통해 EKS와 연동 하여 작업할 수 있게 된다. 

```go
// sts를 이용하여 계정 정보를 조회하고, 환경 변수에 세팅한다. 
ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

// 롤 ARN 을 환경 변수에 설정한다. 
ROLE="    - rolearn: arn:aws:iam::$ACCOUNT_ID:role/EksWorkshopCodeBuildKubectlRole\n      username: build\n      groups:\n        - system:masters"

// config map 에서 aws-auth 정보를 조회하여, map role 정보를 매니페스트 파일에 지정한다. 
kubectl get -n kube-system configmap/aws-auth -o yaml | awk "/mapRoles: \|/{print;print \"$ROLE\";next}1" > /tmp/aws-auth-patch.yml

// config 맵 정보를 업데이트한다. 
kubectl patch configmap/aws-auth -n kube-system --patch "$(cat /tmp/aws-auth-patch.yml)"
```

참고: aws-auth ConfigMap 을 수동으로 편집하려면 아래와 같이 수정하자. 

```go
kubectl edit -n kube-system configmap / aws-auth
```

## Sample Fork 하기. 

[Sample](https://github.com/rnzsgh/eks-workshop-sample-api-service-go) 에서 git 소스 리포지토리를 fork 한다. 

## Github access token 발급하기. 

CodePipeline 이 GitHub로 오는 callback 을 수신하기 위해서 personal access token 을 발급 받아야한다. 

access token 을 발급 받고나면, 이를 secure enclave 에 저장하고, 재 사용할 수 있다. 

이 작업은 오직 처음 토큰을 생성하거나, 다시 생성할때만 수행하면 된다. 

Github > Settings / Developer Setting > Personal access tokens 를 클릭한다. 

- tokenName: eks-user-token
- Select scope: repo 에 체크 

이후 "Generate token" 을 클릭한다. 

## Code Pipeline 설정하기. 

이제 AWS CloudFormation 을 이용하여 CodePipeline을 생성하자. 

CloudFormation 은 IaC 툴이며, 공통적인 언어를 제공하며, 클라우드 환경에서 모든 인프라 리소스를 프로지변 할 수 있다. 

CloudFormation 은 단순 텍스트 파일을 이용하여, 모델링하고 프로비져닝 할 수 있다. 이는 자동화 되고, 보안적인 방법을 제공한다. 

각 EKS deployment/service 는 소유한 CodePipeline이 있으며, 소스 리포지토리와 격리된 위치에 조재한다. 

CloudFormation 템플릿들을 수정하여, 필요한 사항을 변경할 수 있다. 

### 기본 코드 파이프라인 이용 

[ci-cd-codepipeline.cfn.yml](./ci-cd-codepipeline.cfn.yml) 파일을 내용을 확인해보자. 

이중 GitHub 항목에 다음과 같이 추가한다. 

- GitHubUser/Username: <repository 주인의 이름>
- GitHubtoken/AccessToken: <조금전 생성한 토큰>

이후 스택 생성을 하자. 

참고: 위 ci-cd-codepipeline.cfn.yaml 파일 내에서도 github username/access token 항목이 있으므로 수정해서 파일을 cloud formation 에 배포해도 된다. 

CodePipeline 에서 방금만든 스택을 클릭하여 상세 진행 과정을 살펴볼 수 있다. 

### 배포 상태 모니터링 하기. 

```go
kubectl describe deployment hello-k8s
```

service 상태 확인하기. 

```go
kubectl describe service hello-k8s
```

## 새로운 배포 버젼 트리거링 하기. 

지금까지 AWS CodePipeline 을 이용하여 EKS에 CI/CD 를 수행했다. 그리고 이제는 Github 리포지토리 내용이 변경되었을때 새로운 릴리즈를 빌드하고, 릴리즈 해보자. 

GitHub 을 열고 코드를 적정하게 수정한다. 

수정후 "Commit changes" 를 통해서 수정을 커밋한다. 

이후 자동적으로 Code Pipeline 에서 변경 사항을 빌드, 배포 하는 과정을 확인할 수 있다. 

